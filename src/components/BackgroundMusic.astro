---
// src/components/BackgroundMusic.astro
export interface Props {
    src: string;
    volume?: number;
    fadeIn?: boolean;
    showControls?: boolean;
}

const { 
    src, 
    volume = 0.2, 
    fadeIn = true, 
    showControls = true
} = Astro.props;
---

<div class="background-music-container">
    <!-- Audio element -->
    <audio 
        id="background-music" 
        loop 
        preload="auto"
    >
        <source src={src} type="audio/mpeg">
        <source src={src.replace('.mp3', '.ogg')} type="audio/ogg">
    </audio>

    <!-- Controles de música -->
    {showControls && (
        <div class="music-controls" id="music-controls">
            <!-- Handle de arrastre al inicio -->
            <div class="drag-handle" id="drag-handle" title="Arrastra para mover">
                ⋮⋮
            </div>

            <!-- Botón principal de play/pause -->
            <button id="play-pause-btn" class="control-btn" title="Reproducir/Pausar">
                <svg class="play-icon" width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M8 5V19L19 12L8 5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="pause-icon hidden" width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M6 4H10V20H6V4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14 4H18V20H14V4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>

            <!-- Botón de toggle -->
            <button id="toggle-btn" class="control-btn toggle-btn" title="Mostrar/Ocultar controles">
                <svg class="chevron-right" width="18" height="18" viewBox="0 0 24 24" fill="none">
                    <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="chevron-left hidden" width="18" height="18" viewBox="0 0 24 24" fill="none">
                    <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>

            <!-- Controles secundarios -->
            <div class="secondary-controls" id="secondary-controls">
                <div class="volume-slider">
                    <input 
                        type="range" 
                        id="volume-slider" 
                        min="0" 
                        max="1" 
                        step="0.1" 
                        value={volume}
                        class="slider"
                    />
                </div>
                
                <button id="mute-btn" class="control-btn" title="Silenciar/Activar">
                    <svg class="volume-icon" width="20" height="20" viewBox="0 0 24 24" fill="none">
                        <path d="M11 5L6 9H2V15H6L11 19V5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M19.07 4.93A10 10 0 0 1 22 12A10 10 0 0 1 19.07 19.07" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <svg class="mute-icon hidden" width="20" height="20" viewBox="0 0 24 24" fill="none">
                        <path d="M11 5L6 9H2V15H6L11 19V5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M23 9L17 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M17 9L23 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>
        </div>
    )}
</div>

<style>
    .background-music-container {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 9999;
        pointer-events: none;
    }

    .music-controls {
        position: fixed;
        bottom: 30px;
        right: 30px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: var(--primary);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 50px;
        padding: 12px 20px;
        box-shadow: 0 5px 5px rgba(0, 0, 0, 0.3);
        pointer-events: all;
        transition: all 0.3s ease;
        transform: translateY(100px);
        opacity: 0;
        user-select: none;
    }

    .music-controls.show {
        transform: translateY(0);
        opacity: 1;
    }

    .music-controls.dragging {
        transition: none;
        transform: scale(1.05);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
        z-index: 10000;
    }

    .music-controls.minimized .secondary-controls {
        opacity: 0;
        visibility: hidden;
        transform: translateY(-50%) translateX(20px);
        pointer-events: none;
    }

    .drag-handle {
        color: rgba(255, 255, 255, 0.5);
        cursor: grab;
        padding: 8px 4px;
        font-size: 12px;
        line-height: 1;
        user-select: none;
        touch-action: none;
        min-width: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .drag-handle:hover {
        color: rgba(255, 255, 255, 0.8);
    }

    .drag-handle:active {
        cursor: grabbing;
    }

    .control-btn {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        width: 40px;
        height: 40px;
        flex-shrink: 0;
    }

    .control-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: scale(1.1);
    }

    .control-btn:active {
        transform: scale(0.95);
    }

    .toggle-btn {
        width: 40px;
        height: 40px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        position: relative;
    }

    .toggle-btn:hover {
        border-color: rgba(255, 255, 255, 0.4);
    }

    .secondary-controls {
        position: absolute;
        right: 100%;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        align-items: center;
        gap: 12px;
        transition: all 0.3s ease;
        overflow: visible;
        margin-right: 8px;
        background: var(--primary);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 50px;
        padding: 8px 16px;
        opacity: 1;
        visibility: visible;
        white-space: nowrap;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
    }

    .volume-slider {
        display: flex;
        align-items: center;
        width: 80px;
        flex-shrink: 0;
    }

    .slider {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
        transition: background 0.2s ease;
        appearance: none;
        -webkit-appearance: none;
    }

    .slider:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .slider::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        background: #3b82f6;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
        background: #2563eb;
        transform: scale(1.2);
    }

    .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #3b82f6;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        transition: all 0.2s ease;
    }

    .hidden {
        display: none !important;
    }

    /* Asegurar visibilidad en móviles */
    @media (max-width: 768px) {
        .music-controls {
            z-index: 99999 !important;
            pointer-events: all !important;
        }
        
        .music-controls.show {
            display: flex !important;
            opacity: 1 !important;
            transform: translateY(0) !important;
            visibility: visible !important;
        }
    }

    /* Responsive para móviles */
    @media (max-width: 768px) {
        .music-controls {
            bottom: 20px;
            right: 20px;
            padding: 14px 20px;
            gap: 12px;
            transform: translateY(100px);
            opacity: 0;
            min-height: 50px;
        }

        .music-controls.show {
            transform: translateY(0) !important;
            opacity: 1 !important;
            display: flex !important;
            visibility: visible !important;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            padding: 8px;
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
        }

        .toggle-btn {
            width: 44px;
            height: 44px;
        }

        .volume-slider {
            width: 70px;
        }

        .slider {
            height: 4px;
        }

        .slider::-webkit-slider-thumb {
            width: 16px;
            height: 16px;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
        }

        .drag-handle {
            font-size: 14px;
            padding: 8px 6px;
            min-width: 24px;
            touch-action: none;
        }
    }

    /* Para pantallas muy pequeñas */
    @media (max-width: 480px) {
        .music-controls {
            bottom: 15px;
            right: 15px;
            padding: 12px 16px;
            gap: 8px;
            min-height: 45px;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            padding: 6px;
        }

        .control-btn svg {
            width: 18px;
            height: 18px;
        }

        .toggle-btn {
            width: 40px;
            height: 40px;
        }

        .volume-slider {
            width: 60px;
        }

        .slider {
            height: 4px;
        }

        .slider::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
        }

        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
        }

        .drag-handle {
            font-size: 12px;
            padding: 6px 4px;
            min-width: 20px;
            touch-action: none;
        }
    }
</style>

<script>
    console.log('🎵 BackgroundMusic component loaded');
    
    document.addEventListener('DOMContentLoaded', () => {
        console.log('🎵 DOM loaded, starting initialization...');
        
        // Detectar si es móvil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        console.log('🎵 Device detection:', {
            userAgent: navigator.userAgent,
            isMobile: isMobile,
            windowWidth: window.innerWidth,
            windowHeight: window.innerHeight
        });
        
        // Ocultar el audio del componente - el global lo maneja
        const audio = document.getElementById('background-music');
        if (audio) {
            audio.style.display = 'none';
            console.log('🎵 Component audio hidden, using global system');
        }
        
        // Implementar funcionalidad de arrastre
        const musicControls = document.getElementById('music-controls');
        const dragHandle = document.getElementById('drag-handle');
        const toggleBtn = document.getElementById('toggle-btn');
        
        console.log('🎵 Found elements:', {
            musicControls: !!musicControls,
            dragHandle: !!dragHandle,
            toggleBtn: !!toggleBtn,
            windowSize: window.innerWidth + 'x' + window.innerHeight
        });
        
        if (!musicControls) {
            console.error('🎵 musicControls not found!');
            // Intentar crear uno manualmente para móviles
            if (isMobile) {
                console.log('🎵 Attempting to create mobile controls manually...');
                createMobileControls();
            }
            return;
        }
        
        let isDragging = false;
        let isMinimized = false;
        let startX: number, startY: number, initialX: number, initialY: number;
        
        // Mostrar controles - diferente para móvil vs desktop
        if (isMobile) {
            console.log('🎵 Mobile detected - using immediate visibility');
            musicControls.classList.add('show');
            musicControls.style.transform = 'translateY(0)';
            musicControls.style.opacity = '1';
            musicControls.style.visibility = 'visible';
            musicControls.style.display = 'flex';
        } else {
            setTimeout(() => {
                musicControls.classList.add('show');
                console.log('🎵 Desktop controls shown via timeout');
            }, 500);
        }
        
        // Función para minimizar/expandir
        function toggleMinimize() {
            isMinimized = !isMinimized;
            
            if (!toggleBtn) return;
            const chevronLeft = toggleBtn.querySelector('.chevron-left');
            const chevronRight = toggleBtn.querySelector('.chevron-right');
            
            if (isMinimized) {
                if (musicControls) {
                    musicControls.classList.add('minimized');
                }
                if (chevronLeft) chevronLeft.classList.add('hidden');
                if (chevronRight) chevronRight.classList.remove('hidden');
                toggleBtn.title = 'Mostrar controles';
            } else {
                if (musicControls) {
                    musicControls.classList.remove('minimized');
                }
                if (chevronLeft) chevronLeft.classList.remove('hidden');
                if (chevronRight) chevronRight.classList.add('hidden');
                toggleBtn.title = 'Ocultar controles';
            }
            
            localStorage.setItem('music-controls-minimized', isMinimized.toString());
            console.log('🎵 Controls', isMinimized ? 'minimized' : 'expanded');
        }
        
        // Event listener del toggle
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleMinimize();
            });
            
            // Agregar touch events para móviles
            if (isMobile) {
                toggleBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMinimize();
                });
            }
            
            console.log('🎵 Toggle listener added');
        }
        
        // Funcionalidad de arrastre
        function startDrag(e: any) {
            isDragging = true;
            if (musicControls) {
                musicControls.classList.add('dragging');
            }
            
            if (!musicControls) return;
            const rect = musicControls.getBoundingClientRect();
            initialX = rect.left;
            initialY = rect.top;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            startX = clientX - initialX;
            startY = clientY - initialY;
            
            musicControls.style.left = initialX + 'px';
            musicControls.style.top = initialY + 'px';
            musicControls.style.right = 'auto';
            musicControls.style.bottom = 'auto';
        }
        
        function drag(e: any) {
            if (!isDragging) return;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let newX = clientX - startX;
            let newY = clientY - startY;
            
            if (!musicControls) return;
            const rect = musicControls.getBoundingClientRect();
            const maxX = window.innerWidth - rect.width - 10;
            const maxY = window.innerHeight - rect.height - 10;
            
            newX = Math.max(10, Math.min(newX, maxX));
            newY = Math.max(10, Math.min(newY, maxY));
            
            musicControls.style.left = newX + 'px';
            musicControls.style.top = newY + 'px';
        }
        
        function endDrag() {
            if (!isDragging) return;
            
            isDragging = false;
            if (musicControls) {
                musicControls.classList.remove('dragging');
            }
            
            if (musicControls) {
                const rect = musicControls.getBoundingClientRect();
                localStorage.setItem('music-controls-position', JSON.stringify({
                    x: rect.left,
                    y: rect.top
                }));
            }
        }
        
        // Event listeners para arrastre
        if (dragHandle) {
            dragHandle.addEventListener('mousedown', startDrag);
            
            if (isMobile) {
                dragHandle.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startDrag(e);
                }, { passive: false });
            }
            
            console.log('🎵 Drag listeners added');
        }
        
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
        
        if (isMobile) {
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                drag(e);
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                endDrag();
            }, { passive: false });
        }
        
        // Restaurar posición guardada
        const savedPosition = localStorage.getItem('music-controls-position');
        if (savedPosition) {
            try {
                const { x, y } = JSON.parse(savedPosition);
                musicControls.style.left = x + 'px';
                musicControls.style.top = y + 'px';
                musicControls.style.right = 'auto';
                musicControls.style.bottom = 'auto';
                console.log('🎵 Position restored');
            } catch (e) {
                console.log('🎵 Could not restore position');
            }
        }
        
        // Restaurar estado minimizado
        const savedMinimized = localStorage.getItem('music-controls-minimized');
        if (savedMinimized === 'true') {
            toggleMinimize();
        }
        
        console.log('🎵 Component ready');
        
        // DETECTOR DE AUDIO MEJORADO - encuentra el audio DONDE SEA
        let wasPlayingMusic = false;
        let audioCheckInterval: NodeJS.Timeout;
        let foundAudioElements: HTMLAudioElement[] = [];
        
        function findAllAudioElements() {
            let allFound: HTMLAudioElement[] = [];
            
            // PRIORIDAD 1: Buscar el audio global de window.globalAudio
            try {
                // @ts-ignore
                if (window.globalAudio && window.globalAudio instanceof Audio) {
                    // @ts-ignore
                    allFound.push(window.globalAudio);
                    console.log('🎵 FOUND window.globalAudio:', {
                        // @ts-ignore
                        src: window.globalAudio.src,
                        // @ts-ignore
                        paused: window.globalAudio.paused,
                        // @ts-ignore
                        currentTime: window.globalAudio.currentTime,
                        // @ts-ignore
                        duration: window.globalAudio.duration,
                        // @ts-ignore
                        loop: window.globalAudio.loop
                    });
                }
            } catch (e) {
                console.log('🎵 window.globalAudio not accessible:', e);
            }
            
            // PRIORIDAD 2: Buscar otros elementos de audio en el DOM
            const searches = [
                // Búsquedas específicas por ID
                () => document.getElementById('global-background-music') as HTMLAudioElement,
                () => document.getElementById('background-music') as HTMLAudioElement,
                // Búsquedas por atributos
                () => document.querySelector('audio[autoplay]') as HTMLAudioElement,
                () => document.querySelector('audio[loop]') as HTMLAudioElement,
                () => document.querySelector('audio[src]') as HTMLAudioElement,
                // Búsquedas generales
                () => Array.from(document.querySelectorAll('audio')),
                () => Array.from(document.querySelectorAll('[src*=".mp3"]')),
                () => Array.from(document.querySelectorAll('[src*=".ogg"]')),
                () => Array.from(document.querySelectorAll('[src*=".wav"]')),
            ];
            
            searches.forEach((search, index) => {
                try {
                    const result = search();
                    if (result) {
                        if (Array.isArray(result)) {
                            allFound.push(...result.filter(el => el instanceof HTMLAudioElement));
                        } else if (result instanceof HTMLAudioElement) {
                            allFound.push(result);
                        }
                    }
                } catch (e) {
                    console.log(`🎵 Search ${index} failed:`, e);
                }
            });
            
            // PRIORIDAD 3: Buscar en todas las propiedades de window
            try {
                // @ts-ignore
                for (const prop in window) {
                    try {
                        // @ts-ignore
                        const obj = window[prop];
                        if (obj && obj instanceof Audio) {
                            allFound.push(obj);
                            console.log(`🎵 FOUND audio in window.${prop}`);
                        }
                    } catch (e) {}
                }
            } catch (e) {
                console.log('🎵 Window scan failed:', e);
            }
            
            // Eliminar duplicados
            foundAudioElements = Array.from(new Set(allFound));
            
            console.log(`🎵 TOTAL FOUND: ${foundAudioElements.length} audio elements:`, 
                foundAudioElements.map(a => ({
                    id: a.id || 'no-id',
                    src: a.src || 'no-src',
                    paused: a.paused,
                    currentTime: a.currentTime,
                    loop: a.loop,
                    constructor: a.constructor.name
                }))
            );
            
            return foundAudioElements;
        }
        
        function bruteForcePauseAllAudio() {
            // Buscar audio cada vez que se llama
            const allAudio = findAllAudioElements();
            let foundPlayingAudio = false;
            
            // PRIORIDAD 1: Pausar window.globalAudio directamente
            try {
                // @ts-ignore
                if (window.globalAudio && !window.globalAudio.paused) {
                    console.log('🎵 PAUSING window.globalAudio:', {
                        // @ts-ignore
                        src: window.globalAudio.src || 'no-src',
                        // @ts-ignore
                        currentTime: window.globalAudio.currentTime,
                        // @ts-ignore
                        duration: window.globalAudio.duration
                    });
                    // @ts-ignore
                    window.globalAudio.pause();
                    foundPlayingAudio = true;
                    wasPlayingMusic = true;
                }
            } catch (e) {
                console.log('🎵 Could not pause window.globalAudio:', e);
            }
            
            // PRIORIDAD 2: Pausar otros elementos de audio encontrados
            allAudio.forEach((audio, index) => {
                if (audio && !audio.paused) {
                    console.log(`🎵 PAUSING audio ${index}:`, {
                        id: audio.id || 'no-id',
                        src: audio.src || 'no-src',
                        currentTime: audio.currentTime,
                        duration: audio.duration
                    });
                    audio.pause();
                    foundPlayingAudio = true;
                    wasPlayingMusic = true;
                }
            });
            
            // PRIORIDAD 3: Buscar por Web Audio API
            if (window.AudioContext || (window as any).webkitAudioContext) {
                try {
                    const audioContexts = (window as any).__audioContexts__ || [];
                    audioContexts.forEach((ctx: any, index: number) => {
                        if (ctx.state === 'running') {
                            ctx.suspend();
                            foundPlayingAudio = true;
                            wasPlayingMusic = true;
                            console.log(`🎵 SUSPENDED AudioContext ${index}`);
                        }
                    });
                } catch (e) {
                    console.log('🎵 AudioContext error:', e);
                }
            }
            
            if (foundPlayingAudio) {
                console.log('🎵 ✅ AUDIO SUCCESSFULLY PAUSED');
            } else {
                console.log('🎵 ❌ NO PLAYING AUDIO FOUND');
                // Intentar otra búsqueda más agresiva
                setTimeout(() => {
                    const retry = document.querySelectorAll('*');
                    let foundInRetry = false;
                    retry.forEach(element => {
                        if ((element as any).pause && !(element as any).paused) {
                            try {
                                (element as any).pause();
                                foundInRetry = true;
                                console.log('🎵 RETRY: Found and paused element:', element.tagName, element.id);
                            } catch (e) {}
                        }
                    });
                    if (!foundInRetry) {
                        console.log('🎵 RETRY: Still no audio found');
                    }
                }, 100);
            }
        }
        
        function tryResumeAudio() {
            if (!wasPlayingMusic) return;
            
            let resumedAny = false;
            
            // PRIORIDAD 1: Reanudar window.globalAudio directamente
            try {
                // @ts-ignore
                if (window.globalAudio && window.globalAudio.paused) {
                    wasPlayingMusic = false;
                    setTimeout(() => {
                        // @ts-ignore
                        window.globalAudio.play().catch(e => {
                            console.log('🎵 Resume failed for window.globalAudio:', e);
                        });
                        console.log('🎵 ✅ RESUMED window.globalAudio');
                    }, 100);
                    resumedAny = true;
                    return; // Salir temprano si se reanudó el audio global
                }
            } catch (e) {
                console.log('🎵 Could not resume window.globalAudio:', e);
            }
            
            // PRIORIDAD 2: Buscar otros elementos de audio
            const allAudio = findAllAudioElements();
            
            // Intentar reanudar el primer audio pausado
            for (const audio of allAudio) {
                if (audio && audio.paused) {
                    wasPlayingMusic = false;
                    setTimeout(() => {
                        audio.play().catch(e => {
                            console.log('🎵 Resume failed for:', audio.id || 'unnamed', e);
                        });
                        console.log('🎵 RESUMED audio:', audio.id || 'unnamed');
                    }, 100);
                    resumedAny = true;
                    break;
                }
            }
            
            if (!resumedAny) {
                console.log('🎵 ❌ No paused audio found to resume');
            }
        }
        
        // Buscar audio periódicamente hasta encontrarlo
        let audioFoundCount = 0;
        
        // Esperar un poco antes de iniciar la búsqueda para dar tiempo al audio global
        setTimeout(() => {
            console.log('🎵 Starting audio detection system...');
            
            // Búsqueda inicial
            const initialAudio = findAllAudioElements();
            audioFoundCount = initialAudio.length;
            
            if (audioFoundCount > 0) {
                console.log(`🎵 ✅ INITIAL DETECTION: Found ${audioFoundCount} audio elements`);
            } else {
                console.log('🎵 No audio found initially, will keep searching...');
            }
            
            // Continuar buscando cada 2 segundos
            audioCheckInterval = setInterval(() => {
                const found = findAllAudioElements();
                if (found.length > audioFoundCount) {
                    audioFoundCount = found.length;
                    console.log(`🎵 ✅ NEW AUDIO DETECTED! Total: ${found.length}`);
                }
            }, 2000);
        }, 1000); // Esperar 1 segundo antes de empezar
        
        // DETECTOR OPTIMIZADO - menos agresivo, más preciso
        let isPageActive = true;
        let consecutiveFocusLossCount = 0;
        
        // Método 1: Page Visibility API (PRINCIPAL)
        document.addEventListener('visibilitychange', () => {
            const hidden = document.hidden;
            console.log('🎵 Page visibility:', hidden ? 'HIDDEN' : 'VISIBLE');
            
            if (hidden) {
                // Solo pausar si realmente está oculto
                console.log('🎵 Page is HIDDEN - pausing audio');
                isPageActive = false;
                bruteForcePauseAllAudio();
            } else {
                // Reanudar inmediatamente cuando vuelve a ser visible
                console.log('🎵 Page is VISIBLE - resuming audio');
                isPageActive = true;
                tryResumeAudio();
                consecutiveFocusLossCount = 0; // Reset contador
            }
        });
        
        // Método 2: Window Focus (SECUNDARIO - menos agresivo)
        let blurTimeout: NodeJS.Timeout | null = null;
        
        window.addEventListener('blur', () => {
            console.log('🎵 Window BLUR detected');
            
            // Esperar un momento antes de pausar para evitar falsos positivos
            blurTimeout = setTimeout(() => {
                if (!document.hidden && document.hasFocus() === false) {
                    console.log('🎵 Confirmed focus loss - pausing audio');
                    isPageActive = false;
                    bruteForcePauseAllAudio();
                }
            }, 500); // Esperar 500ms antes de pausar
        });
        
        window.addEventListener('focus', () => {
            console.log('🎵 Window FOCUS detected');
            
            // Cancelar timeout de pausa si se recupera el foco rápidamente
            if (blurTimeout) {
                clearTimeout(blurTimeout);
            }
            
            if (!isPageActive) {
                console.log('🎵 Confirmed focus gain - resuming audio');
                isPageActive = true;
                tryResumeAudio();
                consecutiveFocusLossCount = 0;
            }
        });
        
        // Método 3: Polling reducido y menos agresivo
        setInterval(() => {
            const hasFocus = document.hasFocus();
            const isVisible = !document.hidden;
            
            // Solo actuar si hay un cambio real y consistente
            if (!hasFocus && !isVisible && isPageActive) {
                consecutiveFocusLossCount++;
                console.log(`🎵 POLLING: Focus loss detected (${consecutiveFocusLossCount})`);
                
                // Solo pausar después de múltiples detecciones consecutivas
                if (consecutiveFocusLossCount >= 3) {
                    console.log('🎵 POLLING: Confirmed sustained focus loss - pausing');
                    isPageActive = false;
                    bruteForcePauseAllAudio();
                }
            } else if (hasFocus && isVisible && !isPageActive) {
                console.log('🎵 POLLING: Focus regained - resuming');
                isPageActive = true;
                tryResumeAudio();
                consecutiveFocusLossCount = 0;
            } else if (hasFocus || isVisible) {
                // Reset contador si hay cualquier signo de actividad
                consecutiveFocusLossCount = 0;
            }
        }, 1000); // Polling cada 1 segundo (menos frecuente)
        
        // Método 4: Interacciones del usuario (MEJORADO)
        let lastInteraction = Date.now();
        let inactivityTimeout: NodeJS.Timeout | null = null;
        
        function recordInteraction() {
            lastInteraction = Date.now();
            consecutiveFocusLossCount = 0; // Reset contador en cualquier interacción
            
            // Cancelar timeout de inactividad
            if (inactivityTimeout) {
                clearTimeout(inactivityTimeout);
                inactivityTimeout = null;
            }
            
            // Asegurar que está activo si hay interacción
            if (!isPageActive) {
                console.log('🎵 User interaction detected - ensuring audio is active');
                isPageActive = true;
                tryResumeAudio();
            }
        }
        
        // Solo eventos que indican presencia real del usuario
        ['click', 'keydown', 'scroll', 'touchstart', 'mousemove'].forEach(event => {
            document.addEventListener(event, recordInteraction, true);
        });
        
        // Inactividad extrema (solo después de mucho tiempo sin interacción)
        setInterval(() => {
            const timeSinceInteraction = Date.now() - lastInteraction;
            
            // Solo pausar por inactividad si:
            // 1. No hay interacción por más de 10 minutos
            // 2. La página no tiene foco
            // 3. La página no es visible
            if (timeSinceInteraction > 600000 && !document.hasFocus() && document.hidden && isPageActive) {
                console.log('🎵 EXTREME INACTIVITY: 10+ minutes without interaction');
                isPageActive = false;
                bruteForcePauseAllAudio();
            }
        }, 60000); // Verificar cada minuto
        
        console.log('🎵 BRUTE FORCE auto-pause system activated');
        
        // Verificación final para móviles
        if (isMobile) {
            setTimeout(() => {
                const isVisible = musicControls.offsetHeight > 0 && musicControls.offsetWidth > 0;
                console.log('🎵 Mobile visibility check:', {
                    isVisible: isVisible,
                    offsetHeight: musicControls.offsetHeight,
                    offsetWidth: musicControls.offsetWidth,
                    computedDisplay: window.getComputedStyle(musicControls).display,
                    computedOpacity: window.getComputedStyle(musicControls).opacity
                });
            }, 1000);
        }
        
        // Función de emergencia para crear controles en móviles
        function createMobileControls() {
            console.log('🎵 Creating emergency mobile controls...');
            const container = document.querySelector('.background-music-container');
            if (container) {
                const mobileControls = document.createElement('div');
                mobileControls.id = 'music-controls';
                mobileControls.className = 'music-controls show';
                mobileControls.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: rgba(0,0,0,0.8);
                    padding: 14px 20px;
                    border-radius: 25px;
                    display: flex;
                    gap: 12px;
                    z-index: 99999;
                    min-height: 50px;
                    align-items: center;
                `;
                mobileControls.innerHTML = `
                    <button style="background:none;border:none;color:white;padding:8px;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:18px;">⬅️</button>
                    <button style="background:none;border:none;color:white;padding:8px;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:18px;">🔊</button>
                    <button style="background:none;border:none;color:white;padding:8px;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:18px;">▶️</button>
                    <div style="color:rgba(255,255,255,0.5);cursor:grab;padding:8px 6px;font-size:14px;user-select:none;touch-action:none;min-width:24px;display:flex;align-items:center;justify-content:center;">⋮⋮</div>
                `;
                container.appendChild(mobileControls);
                console.log('🎵 Emergency controls created');
                
                // Agregar funcionalidad de arrastre a los controles de emergencia
                const emergencyDragHandle = mobileControls.querySelector('div:last-child');
                if (emergencyDragHandle) {
                    let isDragging = false;
                    let startX: number, startY: number, initialX: number, initialY: number;
                    
                    function startEmergencyDrag(e: any) {
                        isDragging = true;
                        mobileControls.style.transition = 'none';
                        
                        const rect = mobileControls.getBoundingClientRect();
                        initialX = rect.left;
                        initialY = rect.top;
                        
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        
                        startX = clientX - initialX;
                        startY = clientY - initialY;
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    
                    function emergencyDrag(e: any) {
                        if (!isDragging) return;
                        
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        
                        let newX = clientX - startX;
                        let newY = clientY - startY;
                        
                        const rect = mobileControls.getBoundingClientRect();
                        const maxX = window.innerWidth - rect.width - 10;
                        const maxY = window.innerHeight - rect.height - 10;
                        
                        newX = Math.max(10, Math.min(newX, maxX));
                        newY = Math.max(10, Math.min(newY, maxY));
                        
                        mobileControls.style.left = newX + 'px';
                        mobileControls.style.top = newY + 'px';
                        mobileControls.style.right = 'auto';
                        mobileControls.style.bottom = 'auto';
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    
                    function endEmergencyDrag() {
                        if (!isDragging) return;
                        isDragging = false;
                        mobileControls.style.transition = '';
                    }
                    
                    emergencyDragHandle.addEventListener('touchstart', startEmergencyDrag, { passive: false });
                    document.addEventListener('touchmove', emergencyDrag, { passive: false });
                    document.addEventListener('touchend', endEmergencyDrag, { passive: false });
                }
            }
        }
    });
</script>